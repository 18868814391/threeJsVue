<template>
  <div id="p2" ref="p2" class="p2">
    <div class="tip">{{tip}}</div>
    <div class="warn" :style="{top:top+'px',left:left+'px'}">⚠</div>
  </div>
</template>

<script>
import * as THREE from "three";
import Stats from "../stats.js";
import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";
import {interpolateHsl} from "d3-interpolate";
import TWEEN from "@tweenjs/tween.js";
// bloom
import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer.js";
import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "three/examples/jsm/postprocessing/UnrealBloomPass.js";
const clock = new THREE.Clock();
export default {
  data() {
    return {
      MATERIAL_COLOR: "rgb(120, 120, 120)",
      stats: "",
      clock: "",
      tip:'',
      animateList:[],
      top:0,
      left:0,
    };
  },
  mounted() {
    this.scene = "";
    this.light = "";
    this.camera = "";
    this.renderer = "";
    this.controls = "";
    this.bloomComposer="";
    this.stats = new Stats();
    this.clock = new THREE.Clock();
    this.$refs.p2.appendChild(this.stats.dom);
    this.initWorld();
  },
  methods: {
    initWorld() {
      this.scene = new THREE.Scene();
      // 坐标轴辅助器
      // let axesHelper = new THREE.AxesHelper(1500);
      // 网格辅助器
      // let gridHelper = new THREE.GridHelper(100, 100);
      // this.scene.add(axesHelper);
      // this.scene.add(gridHelper);
      this.initLight(1.2);
      this.initCamera();
      this.initRender();
      this.initCity();
      this.initBlom();
    },
    initLight(intensity) {
      // 生成光源
      let ambLight = new THREE.AmbientLight(0x66ffffff);
      this.scene.add(ambLight);

      let light = new THREE.PointLight(0xffffff, intensity);
      light.castShadow = true;
      light.receiveShadow = true;

      light.shadow.bias = 0.001;
      light.shadow.mapSize.width = 2048;
      light.shadow.mapSize.height = 2048;
      light.position.set(1000, 1000, 1000);
      this.scene.add(light);
    },
    initCamera() {
      this.camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      this.camera.position.set(3,3,5);
      this.camera.lookAt(new THREE.Vector3(0, 0, 0));
    },
    initRender() {
      // 3.渲染器
      const self = this;
      this.renderer = new THREE.WebGLRenderer();
      this.renderer.setClearColor();
      this.renderer.shadowMap.enabled = true; // 开启渲染器的阴影功能
      this.renderer.shadowMap.type = THREE.PCFShadowMap; // PCF阴影类型
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.$refs.p2.appendChild(self.renderer.domElement);
      this.renderer.render(this.scene, this.camera);
      this.controls = new OrbitControls(this.camera, this.renderer.domElement); // 创建控件对象
      this.controls.addEventListener("change", () => {
        this.renderer.render(this.scene, this.camera);
      }); // 监听鼠标、键盘事件
    },
    initBlom(){
      const self=this
      const renderScene = new RenderPass( this.scene, this.camera );
      const bloomPass  = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
      bloomPass .threshold = 0.3;
      bloomPass .strength = 2;
      bloomPass .radius = 0.3;
      this.bloomComposer = new EffectComposer( self.renderer );
      this.bloomComposer.addPass( renderScene );
      this.bloomComposer.addPass( bloomPass  );      
    },
    initCity(){
      const self=this
      let env=process.env.NODE_ENV
      let model = "";
      const loader = new GLTFLoader();
      loader.load( `${env=='development'?'':'/threeJs'}/module/b-city.glb`, function ( gltf ) {
        model = gltf.scene;
        console.log('p2',model)
        const list = [...model.children];
        list.forEach(item=>{
          self.change2BasicMat(item);
        });        
        model.position.set(0, 0, 0);
        self.scene.add(model);
        self.addElevator(gltf)
        self.addRoads()      
        self.animate();
      },self.handleProgress)
    },
    handleProgress(progressEvent) {
      console.log("handleProgress",progressEvent.loaded,progressEvent.total);
      this.tip = `加载模型中:${(progressEvent.loaded/progressEvent.total * 100).toFixed(0) }%`;
    },      
    animate(){
      const self=this
      const delta = clock.getDelta();
      this.animateList.forEach(mixer=>{
        mixer.update( delta );
      });
      TWEEN.update();
      this.setStaticPosition()
      this.bloomComposer.render();
      this.stats.begin();
      requestAnimationFrame( self.animate );
      this.stats.end();
    },
    addRoads(){
      const self=this
      const roadNum = 4;
      for(let i = 1;i<=roadNum;i++){
        const name = `road${i?"00"+i:""}`;
        const road = self.scene.getObjectByName(name);
        self.change2LightTrail(road);
      }  
    },
    addElevator(gltf){
      const self=this
      const elevatorList = ["Elevator","Elevator001"];
      elevatorList.forEach((item,index)=>{
        const elevator = self.scene.getObjectByName(item);
        console.log('elevatorelevator',elevator)
        const mesh = self.change2LightBox(elevator);
        // 创建Animation
        const mixer = new THREE.AnimationMixer( mesh );
        const clipAction = mixer.clipAction( gltf.animations[index] );
        clipAction.play();
        self.animateList.push(mixer);
      });
    },
    change2BasicMat(object3d){
      const basicMat = new THREE.MeshBasicMaterial({
        opacity: 0.25 ,
        color:0x1f56b9,
        side: THREE.BackSide,
        transparent: true,
      });    
      object3d.traverse(item=>{
        if(item.material){
          item.material = basicMat;
        }
      });
    },
    change2LightTrail(object3d) {
      const self=this
      // 使用顶点颜色 VertexColors
      const material = new THREE.MeshBasicMaterial( { vertexColors: THREE.VertexColors,side: THREE.BackSide } );
      const geometry = object3d.geometry.clone();
      // 生成渐变色的color数组
      const count = geometry.attributes.position.count;
      const rgbInterpolate = interpolateHsl("#00ffff", "#000000");
      const colorArray = new Array(count);
      for (let index = 0; index < count; index++) {
        const t = index / count;
        const rgb = rgbInterpolate(t);
        const rgbValue = rgb.match(/\d+/g);
        // 从 "rgb(1,2,3)" 字符串里 提取出 1,2,3 并 归一化（ 0.0 ~ 1.0）
        const r = Number(rgbValue[0]) / 255;
        const g = Number(rgbValue[1]) / 255;
        const b = Number(rgbValue[2]) / 255;

        colorArray[3 * index] =  r;
        colorArray[3 * index + 1] = g;  
        colorArray[3 * index + 2] =  b;
      }

      const anchor = Number((Math.random() * count).toFixed(0));
      const b = colorArray.slice(anchor * 3);
      const f = colorArray.slice(0, anchor * 3);
      const newColorArray = [].concat(b, f) ;

      geometry.setAttribute( "color", new THREE.Float32BufferAttribute( newColorArray, 3 ) );
      const mesh = new THREE.Mesh( geometry, material);
      mesh.position.set(object3d.position.x,object3d.position.y,object3d.position.z);
      mesh.rotation.set(object3d.rotation.x,object3d.rotation.y,object3d.rotation.z);
      mesh.scale.set(object3d.scale.x,object3d.scale.y,object3d.scale.z);
      object3d.parent.add(mesh);
      self.lightMove(mesh,newColorArray);
      setInterval(() => {
        self.lightMove(mesh,newColorArray);
      }, 2000);
    },    
    // 颜色变化
    lightMove(mesh,colorArray) {
      const len = colorArray.length/3;
      new TWEEN.Tween({value:0})
      .to({value:1}, 2000)
      .onUpdate(function (val) {
        // 实现环状数组变化
        const anchor = Number((val.value * len).toFixed(0));
        const b = colorArray.slice(anchor * 3);
        const f = colorArray.slice(0, anchor * 3);
        const newColorArray = [].concat(b, f) ;
        mesh.geometry.setAttribute( "color", new THREE.Float32BufferAttribute( newColorArray, 3 ) );
      })
      .start();
    },
    change2LightBox(object3d){
      const group = new THREE.Group();
      const lineMaterial = new THREE.LineBasicMaterial({color: 0x00FFFF});
      const boxMaterial = new THREE.MeshBasicMaterial({
        opacity: 0.1 ,
        color:0x00cccc,
        side: THREE.BackSide,
        transparent: true,
      });
      const geo = new THREE.EdgesGeometry(object3d.geometry);
      const line = new THREE.LineSegments( geo , lineMaterial);
      const box = new THREE.Mesh(object3d.geometry, boxMaterial);
      
      group
      .add(line)
      .add(box);

      group.position.set(object3d.position.x,object3d.position.y,object3d.position.z);
      group.rotation.set(object3d.rotation.x,object3d.rotation.y,object3d.rotation.z);
      group.scale.set(object3d.scale.x,object3d.scale.y,object3d.scale.z);

      object3d.parent.add(group);
      object3d.visible = false;
      return group;
    },
    setStaticPosition(){
      const self=this
      const box3 = new THREE.Box3();
      const object3d = this.scene.getObjectByName("road003");
      const widthHalf = window.innerWidth / 2;
      const heightHalf = window. innerHeight / 2;
      // 获取在3D空间里的坐标
      const vector = new THREE.Vector3();
      box3.setFromObject(object3d);
      box3.getCenter(vector);
      vector.project(self.camera);
      // 转换成平面坐标
      this.left=vector.x * widthHalf + widthHalf;
      this.top=-(vector.y * heightHalf) + heightHalf;
    }  
  },
};
</script>

<style lang="less" scoped>
.p2 {
  width: 100vw;
  height: 100vh;
  position: relative;
  .tip{
    position: absolute;
    top: 0;
    left: 50%;
    transform: translateX(-50%);
    color: white;
    font-size: 16px;
    text-indent: 20px;
  }
  .warn{
    position: absolute;
    color: red;
    font-size: 30px;
  }
}
</style>
